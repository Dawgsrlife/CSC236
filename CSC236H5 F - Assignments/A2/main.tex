\documentclass[12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{newunicodechar}
\newunicodechar{‚Ñù}{\mathbb{R}}
\usepackage{EngReport}
\usepackage{listings}
\usepackage{cancel}
\usepackage{comment}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{geometry}
\usepackage{xcolor}  % Required for coloring in listings

\graphicspath{{Images/}}
\onehalfspacing
\geometry{letterpaper, portrait, includeheadfoot=true, hmargin=1in, vmargin=1in}

% Define custom colors
\definecolor{myblue}{RGB}{0, 128, 255}
\definecolor{mygreen}{RGB}{34, 139, 34}
\definecolor{myorange}{RGB}{255, 140, 0}
\definecolor{mygray}{RGB}{128, 128, 128}
\definecolor{mypurple}{RGB}{148, 0, 211}
\definecolor{myred}{RGB}{255, 69, 0}

% Configure listings for Python with custom styles
\lstset{
    language=Python,             % Set language to Python
    basicstyle=\ttfamily\small,  % Use a smaller monospace font
    keywordstyle=\color{myblue}\bfseries,  % Keywords in blue and bold
    commentstyle=\color{mygreen}\itshape,  % Comments in green and italic
    stringstyle=\color{myorange},          % Strings in orange
    numberstyle=\color{mygray},            % Line numbers in gray
    identifierstyle=\color{mypurple},      % Functions and variables in purple
    morekeywords={print, len, range},      % Define additional Python keywords
    showstringspaces=false,                % Do not show spaces in strings
    breaklines=true,                       % Enable line breaking
    numbers=left,                          % Add line numbers to the left
    numbersep=5pt,                         % Space between line numbers and code
    frame=single,                          % Add a box around the code
    rulecolor=\color{mygray},              % Frame color
    moredelim=[is][\color{myred}]{@@}{@@}, % Custom inline LaTeX coloring
}

\begin{document}
\renewcommand{\familydefault}{\rmdefault}

\input{titlepage}
\input{headerfooter}
\pagebreak
\normalsize

\section*{Question \#1}
Consider the following program from pg. 53-54 of the course textbook:
\begin{lstlisting}
def avg(A):
    """
    Pre: A is a non-empty list
    Post: Returns the average of the numbers in A
    """
    sum = 0
    i = 0
    while i < len(A):
        sum += A[i]
        i += 1
    return sum / len(A)

print(avg([1, 2, 3, 4]))  # Example usage
\end{lstlisting}
Denote the predicate:
\[
Q(j): \text{At the beginning of the } j^{\text{th}} \text{ iteration, } \texttt{sum}_j = \sum_{k=0}^{i_j-1} A[k].
\]
\textbf{\underline{Claim:}} \\
$\forall j \in \{1, \dots, len(A)\}, Q(j)$
\begin{proof}
\leavevmode\\
    This proof leverages the Principle of Simple Induction. \\
    \\
    \underline{Base Case:} \\
    Let $j = 1$. \\
    \\
    At the beginning of the $1^{\text{st}}$ iteration, $\texttt{sum}_1 = 0$ and $i_1 = 0$. \\
    \\
    It follows that
    \[
    \texttt{sum}_1 = \sum_{k=0}^{i_1-1} A[k]
    = \sum_{k=0}^{0-1} A[k]
    = \sum_{k=0}^{-1} A[k]
    = 0\text{.}
    \]
    Hence, \(Q(1)\). \\
    \\
    \underline{Induction Hypothesis:} \\
    Assume for some iteration $m \in \{ 1, ..., len(A) - 1 \}$, $Q(m)$. \\
    \\
    Namely, for the $m^{\text{th}}$ iteration,
    \[\texttt{sum}_m = \sum_{k = 0}^{i_m - 1} A[k] \text{.}\]
    \\
    \underline{Induction Step:} \\
    Proceed to show \(Q(m + 1)\): \\
    \\
    Notice that \(\texttt{sum}_{m + 1} = \texttt{sum}_m + A[i_{m + 1}]\), by \textit{Line 9} of the program. \\
    \\
    By the Induction Hypothesis,
    \[
    \texttt{sum}_m + A[i_{m + 1}]
    = \sum_{k = 0}^{i_m - 1} A[k] + A[i_{m + 1}] \text{,}
    \]
    and by \textit{Line 10} of the program, \(i_{m + 1} = i_m + 1\);
    \[
    \sum_{k = 0}^{i_m - 1} A[k] + A[i_{m + 1}]
    = \sum_{k = 0}^{i_{m + 1} - 1} A[k] \text{.}
    \]
    Thus,
    \[
    \texttt{sum}_{m + 1} = \sum_{k = 0}^{i_{m + 1} - 1} A[k]
    \]
    as needed. \\
    \\
    Therefore, by the Principle of Simple Induction, $Q(j)$ holds for all $j \in \{1, \dots, len(A)\}$. \\
\end{proof}
\pagebreak
\section*{Question \#2}
Recall \(Q(j)\) from \textit{Question \# 1}: \\
\[
Q(j): \text{At the beginning of the } j^{\text{th}} \text{ iteration, } \texttt{sum}_j = \sum_{k=0}^{i_j-1} A[k].
\]
\\
Denote the following predicate:
\[
    Q'(n): 0 \leq n < len(A) \implies Q(n + 1)
\]
\textbf{\underline{Claim:}} \\
Proving $\forall j \in \{ 1, \dots, len(A) \}, Q(j)$ is equivalent to proving $\forall n \in \mathbb{N}, Q'(n)$.

\begin{proof}
\leavevmode\\
    \underline{Remarks} \\
    It is sufficient to show that $\forall j \in \{ 1, \dots, len(A) \}, Q(j) \iff \forall n \in \mathbb{N}, Q'(n)$, to show that proving one of these statements is equivalent to proving the other. \\
    \\
    \underline{$(\forall j \in \{ 1, \dots, len(A) \}, Q(j)) \implies (\forall n \in \mathbb{N}, Q'(n))$:} \\
    Suppose $\forall j \in \{ 1, \dots, len(A) \}, Q(j)$. \\
    \\
    Then, fix $n \in \mathbb{N}$ and suppose $0 \leq n <  len(A)$. \\
    \\
    Because $n \in \{0, ..., len(A) - 1\}$, it follows that $(n + 1) \in \{ 1, \dots, len(A) \} $. \\
    \\
    By assumption, $Q(n + 1)$. \\
    \\
    Thus, $\forall n \in \mathbb{N}, Q'(n)$. \\
    \\
    \underline{$(\forall j \in \{ 1, \dots, len(A) \}, Q(j)) \impliedby (\forall n \in \mathbb{N}, Q'(n))$:} \\
    Suppose $\forall n \in \mathbb{N}, Q'(n)$. \\
    \\
    Let $j \in \{ 1, \dots, len(A) \}$. \\
    \\
    Then, $(j - 1) \in \mathbb{N}$. \\
    \\
    It follows that $0 \leq j - 1 \leq len(A) - 1$. \\
    \\
    Since $len(A) - 1 < len(A)$, $0 \leq j - 1 < len(A)$. \\
    \\
    By assumption, $Q((j - 1) + 1)$. \\
    \\
    Thus, $\forall j \in \{1, \dots, len(A)\}, Q(j)$. \\
    \\
    \underline{Conclusion:} \\
    Therefore, $\forall j \in \{ 1, \dots, len(A) \}, Q(j) \iff \forall j \in \mathbb{N}, Q'(n)$. \\
\end{proof}
\pagebreak
\section*{Question \#3}
As follows below, Q6-Q10 respectively represent questions 6 through 10 from pp. 64-66 of the course textbook. \\
\\
\textbf{Q6:} \\
Consider the following code:
\begin{lstlisting}
def f(x):
    """Pre: x is a natural number"""
    a = x
    y = 10
    while a > 0:
        a -= y
        y -= 1
    return a * y
\end{lstlisting}
\underline{\textbf{(a):} Loop Invariant Which Characterizes \texttt{a} and \texttt{y}:} \\
For arbitrary natural n... \\
Let $i_1 = 0$ and $i_n = i_{n-1} + 1$. \\
Let $y_n$ be the value of $y$ before the $(n + 1){\text{th}}$ iteration. By \textit{Line 4} (initializes $y = 10$) and \textit{Line 7} (decrements $y$ by $1$) of the program, $y_n = 10 - \sum_{q = 1}^{n} 1 = 10 - n \times 1 = 10 - n$. \\
Denote the loop invariant: \\
\[
P(j): (a_j = x - \sum_{k = 0}^{i_j - 1} y_k) \land (y_j = 10 - j)
\]
\\
For example, before the $1^{\text{st}}$ iteration, $a_1 = x - \sum_{k = 0}^{i_1 - 1} y_k = x - \sum_{k = 0}^{0 - 1} y_k = x - 0 = x$. \\
\\
Before the $2^{\text{nd}}$ iteration, $a_2 = x - \sum_{k = 0}^{i_2 - 1} y_k = x - \sum_{k = 0}^{1 - 1} y_k = x - y_0 = x - 10$. \\
\\
\underline{\textbf{(b):} Why This Function Fails to Terminate} \\
Suppose $x > \sum_{k=1}^{10} k = 55$. \\
\\
By $P(j)$, before the $11^{\text{th}}$ iteration, $a_{11} = x - \sum_{k = 0}^{i_{11} - 1} y_k = x - \sum_{k = 0}^{10 - 1} y_k = x - \sum_{k = 0}^{9} (10 - k) = x - [10\sum_{k = 0}^{9} (1) - \sum_{k = 0}^{9} (k)] = x - [10(10) - \frac{9(9 + 1)}{2}] = x - [100 - 45] = x - 55$. \\
\\
Since $x > 55$, it follows that $a_{11} = x - 55 > 0$. \\
\\
As well, $y_{10}$ (the value of $y$ after the $11^{\text{th}}$ iteration) is $10 - 11 = -1$. \\
\\
Notice that in all subsequent iterations, $a$ will decrement by $y_n < 0 |_{n \geq 11}$ (where $n$ is the iteration number of the corresponding iteration). \\
\\
Since $a$ decrements by a negative number subsequently, the loop causes $a$ to grow large, thereby retaining $a > 0$. \\
\\
Thus, the function fails to terminate for $x > 55$ (because $\neg (a > 0)$ is never satisfied). \\
\\
\textbf{Q7:} \\
\textbf{(a)} Consider the recursive program below:
\begin{lstlisting}
def exp_rec(a, b):
    if b == 0:
        return 1
    else if b mod 2 == 0:
        x = exp_rec(a, b / 2)
        return x * x
    else:
        x = exp_rec(a, (b - 1) / 2)
        return x * x * a
\end{lstlisting}
\underline{Preconditions:}
\[
    (b \in \mathbb{N}) \land (a \neq 0)
\]
\underline{Postconditions:}
\[
    \text{Returns } a^b \text{.}
\]
Denote the following predicate:
\[P(b): \text{The program returns } a^b \text{.}\]
\textbf{\underline{Claim:}} \(\forall b \in \mathbb{N}, P(b)\) 
\begin{proof}
\leavevmode\\
    This proof explores the Principle of Complete Induction on $b$. \\
    \\
    Fix $a \neq 0$. \\
    \\
    \underline{Base Case:} \\
    Let $b = 0$. \\
    \\
    Then, by \textit{Lines 2-3} of the program, the program returns $1 = a^0 = a^b$. \\
    \\
    Hence, $P(0)$. \\
    \\
    \underline{Induction Hypothesis:} \\
    Assume for some \(k \in \mathbb{N}\) and for all \(l \in [0, k] \cap \mathbb{N}\), \(P(l)\). \\
    \\
    This means the program returns $a^l$ for every $l$ as described. \\
    \\
    \underline{Induction Step:} \\
    Proceed to show \(P(k + 1)\) with case analysis: \\
    \\
    \textit{Case 1 - Suppose $(k + 1) (\text{mod } 2) \not\equiv 0$:} \\
    Then, program again enters the \texttt{else} statement in \textit{Line 7}. \\
    \\
    Here, the program sets $x$ to \verb|exp_rec(a, ((k + 1) - 1) / 2)|. \\
    \\
    Notice that \(\verb|exp_rec(a, ((k + 1) - 1) / 2)| = \verb|exp_rec(a, (k / 2))|\). \\
    \\
    Since $(k + 1)(\text{mod } 2) \not\equiv 0$, it must be that $k (\text{mod 2} \equiv 0)$. \\
    \\
    Thus, $\frac{k}{2} \in \mathbb{N}$ and $\frac{k}{2} < k$. \\ 
    \\
    By the Induction Hypothesis, \verb|exp_rec(a, k / 2)| returns $a^{\frac{k}{2}}$. \\
    \\
    Finally, the original function call returns $x \times x \times a$, which evaluates to $a^{\frac{k}{2}} \times a^{\frac{k}{2}} \times a = a^{\frac{k}{2} + \frac{k}{2} + 1} = a^{k + 1}$, as needed. \\
    \\
    Thus, $P(k + 1)$ holds. \\
    \\
    \textit{Case 2 - Suppose $(k + 1) (\text{mod } 2) \equiv 0$:} \\
    Then, the program reaches \textit{Line 5} and sets $x$ to \verb|exp_rec(a, (k + 1) / 2)|. \\
    \\
    Notice that $\frac{k + 1}{2} \in \mathbb{N}$ and $\frac{k + 1}{2} \leq k$. \\
    \\
    By the Induction Hypothesis, \verb|exp_rec(a, (k + 1) / 2)| returns $a^{\frac{k + 1}{2}}$. \\
    \\
    Finally, the original function call returns $x \times x$, evaluating to $a^{\frac{k + 1}{2}} \times a^{\frac{k + 1}{2}} = a^{\frac{k + 1}{2} + \frac{k + 1}{2}} = a^{k + 1}$, as needed. \\
    \\
    Thus, P(k + 1) holds. \\
    \\
    \underline{Conclusion:} \\
    Therefore, $P(k + 1)$ holds in all cases. \\
    \\
    By the Principle of Complete Induction, $\forall b \in \mathbb{N}, P(b)$. \\
\end{proof}
\leavevmode\\
\textbf{(b)} Consider the iterative version of the previous program:
\begin{lstlisting}
def exp_iter(a, b):
    ans = 1
    mult = a
    exp = b
    while exp > 0:
        if exp mod 2 == 1:
            ans *= mult
        mult = mult * mult
        exp = exp // 2
    return ans
\end{lstlisting}
\underline{Preconditions:}
\[
    (b \in \mathbb{N}) \land (a \neq 0)
\]
\underline{Postconditions:}
\[
    \text{Returns } a^b \text{.}
\]
\textbf{\underline{Claim:}} For all natural $b$, the program returns $a^b$ and terminates.
\begin{proof}
\leavevmode\\
    Fix $a \neq 0$ and $b \in \mathbb{N}$. \\
    \\
    \underline{Loop Invariant Proof:} \\
    Denote the Loop Invariant:
    \[P(i): a^b = \verb|mult|_i^{\verb|exp|_i} \times \verb|ans|_i \]
    To prove the loop invariant, this proof explores the Principle of Simple Induction on $i \in [1, \lfloor log_2b \rfloor + 2] \cap \mathbb{N}$. \\
    \\
    \underline{Base Case:} \\
    Let $i = 1$. \\
    \\
    Then, the program retains the values $\verb|mult|_1 = a$, $\verb|exp|_1 = b$, $\verb|ans_1 = 1|$. \\
    \\
    Notice that $a^b = a^b \times 1 = \verb|mult|_1^{\verb|exp|_1} \times \verb|ans|_1$. \\
    \\
    Hence, at the beginning of the $1^{\text{st}}$ iteration, $P(1)$. \\
    \\
    \underline{Induction Hypothesis:} \\
    Assume for some $k \in [1, \lfloor log_2b \rfloor + 1] \cap \mathbb{N}, P(k)$;
    \[
        P(k): (a^b = \verb|mult|_k^{\verb|exp|_k} \times \verb|ans|_k) \text{.}
    \]
    \underline{Induction Step:} \\
    Notice that $\verb|exp|_k = \lfloor \frac{b}{2^{k - 1}} \rfloor$. \\
    \\
    Because $k - 1 \leq \lfloor log_2b \rfloor$, then $2^{k - 1} \leq 2^{\lfloor log_2b \rfloor} \leq 2^{log_2b} = b$. \\
    \\
    Therefore, it follows that \(\frac{b}{2^{k - 1}} \geq 1\). \\
    \\
    Thus, $\verb|exp|_k = \lfloor \frac{b}{2^{k - 1}} \rfloor \geq 1$, and the following iteration runs. \\
    \\
    Then, the program yields the following values:
    \[
    \left\{
    \begin{array}{ll}
    \verb|mult|_{k + 1} = \verb|mult|_k \times \verb|mult|_k = \verb|mult|_k^2, & \hspace{1cm} \text{by \textit{Line 8}} \\
    \verb|exp|_{k + 1} = \left\lfloor \frac{\texttt{exp}_k}{2} \right\rfloor, & \hspace{1cm} \text{by \textit{Line 9}}
    \end{array}
    \right.
    \]
    \\
    Notice that \(\verb|mult|_{k + 1}^{\verb|exp|_{k + 1}} = (\verb|mult|_k^2)^{\lfloor \frac{\texttt{exp}_k}{2} \rfloor} = \verb|mult|_k^{2 \lfloor \frac{\texttt{exp}_k}{2} \rfloor}\). \\
    \\
    Proceed to show $P(k + 1)$ with case analysis: \\
    \\
    \underline{\textit{Case 1 - Suppose \(exp_k (\text{mod } 2) \equiv 1\):}} \\
    By \textit{Lines 6-7} of the program, \(\verb|ans|_{k + 1} = \verb|ans|_k \times \verb|mult|_k\). \\
    \\
    So, \((\verb|mult|_{k + 1}^{\verb|exp|_{k + 1}}) \times (\verb|ans|_{k + 1}) = (\verb|mult|_k^{2 \lfloor \frac{\texttt{exp}_k}{2} \rfloor}) \times (\verb|ans|_k \times \verb|mult|_k)\). \\
    \\
    Since \(\verb|exp|_k (\text{mod } 2) \equiv 1\), it follows that \(2 \lfloor \frac{\texttt{exp}_k}{2} \rfloor = \cancel{2} (\frac{\texttt{exp}_k - 1}{\cancel{2}}) = \verb|exp|_k - 1\). \\
    \\
    Thus,
    \begin{equation*}
        \begin{aligned}
            (\verb|mult|_k^{2 \lfloor \frac{\texttt{exp}_k}{2} \rfloor}) \times (\verb|ans|_k \times \verb|mult|_k) &= (\verb|mult|_k^{\verb|exp|_k - 1}) \times (\verb|mult|_k \times \verb|ans|_k) \\
            &= \verb|mult|_k^{\verb|exp|_k - 1} \times \verb|mult|_k \times \verb|ans|_k \\
            &= (\verb|mult|_k^{\verb|exp|_k - 1} \times \verb|mult|_k) \times \verb|ans|_k \\
            &= (\verb|mult|_k^{(\verb|exp|_k - 1) + 1}) \times \verb|ans|_k \\
            &= \verb|mult|_k^{\verb|exp|_k} \times \verb|ans|_k \\
            &= a^b \text{,}
        \end{aligned}
    \end{equation*}
    by the Induction Hypothesis.
    \\
    Therefore, \((\verb|mult|_{k + 1}^{\verb|exp|_{k + 1}}) \times (\verb|ans|_{k + 1}) = a^b\); $P(k + 1)$ holds. \\
    \\
    \underline{\textit{Case 2 - Suppose \(exp_k (\text{mod } 2) \not\equiv 1\):}} \\
    By \textit{Line 6} of the program, \textit{Line 7} does not run. \\
    \\
    Hence, $\verb|ans|_{k + 1}$ retains the value as represented by $\verb|ans|_k$; \(\verb|ans|_{k + 1} = \verb|ans|_k\). \\
    \\
    So, \((\verb|mult|_{k + 1}^{\verb|exp|_{k + 1}}) \times (\verb|ans|_{k + 1}) = (\verb|mult|_k^{2 \lfloor \frac{\texttt{exp}_k}{2} \rfloor}) \times \verb|ans|_k\). \\
    \\
    Notice that \(\verb|exp|_k (\text{mod } 2) \not\equiv 1 \iff \verb|exp|_k (\text{mod } 2) \equiv 0\). \\
    \\
    So, \(2 \lfloor \frac{\texttt{exp}_k}{2} \rfloor = \cancel{2} (\frac{\texttt{exp}_k}{\cancel{2}}) = \verb|exp|_k\). \\
    \\
    Then, it follows that \((\verb|mult|_k^{2 \lfloor \frac{\texttt{exp}_k}{2} \rfloor}) \times \verb|ans|_k = (\verb|mult|_k^{\verb|exp|_k}) \times \verb|ans|_k = a^b\), by the Induction Hypothesis. \\
    \\
    Still, \((\verb|mult|_{k + 1}^{\verb|exp|_{k + 1}}) \times (\verb|ans|_{k + 1}) = a^b\); $P(k + 1)$ likewise holds. \\
    \\
    \underline{Conclusion of Loop Invariant:} \\
    Collectively, $P(k + 1)$ holds in all cases. \\
    \\
    By the Principle of Simple Induction, $P(i)$ holds for all $i \in [1, \lfloor log_2b \rfloor + 2]$. \\
    \\
    \underline{Program Termination Proof} \\
    Notice that \textit{Line 9} of the program performs floor division by $2$ on \texttt{exp} in each iteration. \\
    \\
    From continual division, \texttt{exp} eventually becomes small enough that it reaches $0$ through the next floor division by $2$. \\
    \\
    Since the program's loop requires $\texttt{exp} > 0$ to run, having \texttt{exp} reach $0$ indeed terminates the loop. \\
    \\
    \underline{Conclusion:} \\
    Therefore, this program is both correct (by the loop invariant) and terminates. \\
\end{proof}
\leavevmode\\
\textbf{Q8} \\
Consider the following linear time program:
\begin{lstlisting}
    def majority(A):
        """
        Pre: A is a list with more than half its entries equal to x
        Post: Returns the majority element x
        """
        c = 1
        m = A[0]
        i = 1
        while i <= len(a) - 1:
            if c == 0:
                m = A[i]
                c = 1
            else if A[i] == m:
                c += 1
            else:
                c -= 1
            i += 1
        return m
\end{lstlisting}
Denote the following predicate:
\[P(n): somethinghere\]
\textbf{\underline{Claim:}} expresshowthisiscorrect
\begin{proof}
\leavevmode\\
    wordsgohere \\
\end{proof}
\leavevmode\\
\textbf{Q9} \\
Consider the bubblesort algorithm as follows:
\begin{lstlisting}
    def bubblesort(L):
        """
        Pre: L is a list of numbers
        Post: L is sorted
        """
        k = 0
        while k < len(L):
            i = 0
            while i < len(L) - k - 1:
                if L[i] > L[i + 1]:
                    swap L[i] and L[i + 1]
                i += 1
            k += 1
\end{lstlisting}
\textbf{(a):} Denote the inner loop's invariant:
\[P(n): somethinghere\]
\textbf{\underline{Claim:}} proveinnerloop
\begin{proof}
\leavevmode\\
    wordsgohere \\
\end{proof}
\leavevmode
\textbf{(b):} Denote the outer loop's invariant:
\[P(n): somethinghere\]
\textbf{\underline{Claim:}} proveouterloop
\begin{proof}
\leavevmode\\
    wordsgohere \\
\end{proof}
\leavevmode
\textbf{(c):} Denote the following predicate:
\[P(n): somethinghere\]
\textbf{\underline{Claim:}} expresshowthisiscorrect
\begin{proof}
\leavevmode\\
    wordsgohere \\
\end{proof}
\leavevmode\\
\textbf{Q10} \\
Consider the following generalization of the \texttt{min} function:
\begin{lstlisting}
    def extract(A, k):
        pivot = A[0]
        # Use partition from quicksort
        L, G = partition(A[1, ..., len(A) - 1], pivot)
        if len(L) == k - 1:
            return pivot
        else if len(L) >= k:
            return extract(L, k)
        else:
            return extract(G, k - len(L) - 1)
\end{lstlisting}
\textbf{(a):} Proof of Correctness \\
\[P(n): somethinghere\]
\textbf{\underline{Claim:}} proofofcorrectnessclaim
\begin{proof}
\leavevmode\\
    wordsgohere \\
\end{proof}
\leavevmode\\
\textbf{(b):} Worst-Case Runtime \\
wordsgohere \\
\\
\pagebreak
\section*{Question \#4}
As follows below, VI, VII, X, XII, and XIV respectively represent questions 6, 7, 10, 12, and 14 from pp. 46-48 of the course textbook. \\
\\
\textbf{VI} \\
Let $T(n)$ be the number of binary strings of length $n$ in which there are no consecutive $1$'s. So, \(T(0) = 1, T(1) = 2, T(2) = 3, ...\), etc. \\
\\
\textbf{(a):} Recurrence for $T(n)$: \\
recurrencehere \\
\\
\textbf{(b):} Closed Form Expression for $T(n)$: \\
closedformhere \\
\\
\textbf{(c):} Proof of Correctness of Closed Form Expression \\
Denote the following predicate: \\
\[P(n): somethinghere\]
\textbf{\underline{Claim:}} expresshowthisiscorrect
\begin{proof}
\leavevmode\\
    wordsgohere \\
\end{proof}
\leavevmode\\
\textbf{VII} \\
Let $T(n)$ denote the number of distinct full binary trees with $n$ nodes. For example, $T(1) = 1$, $T(3) = 1$, and $T(7) = 5$. Note that every full binary tree has an odd number of nodes. \\
\textbf{\underline{Recurrence for $T(n)$:}} \\
recurrencehere \\
\[P(n): somethinghere\]
\large \textbf{\underline {Claim:}} \(T(n) \geq (\frac{1}{n})(2)^{(n - 1) / 2}\)
\normalsize
\begin{proof}
\leavevmode\\
    wordsgohere \\
\end{proof}
\leavevmode\\
\textbf{X} \\
A \textit{block} in a binary string is a maximal substring consisting of the same symbol. For example, the string \texttt{0100011} has four blocks: \texttt{0}, \texttt{1}, \texttt{000}, and \texttt{11}. Let $H(n)$ denote the number of binary strings of length $n$ that have no odd length blocks of \texttt{1}'s. For example, $H(4) = 5$:
\[
0000 \;\; 1100 \;\; 0110 \;\; 0011 \;\; 1111
\]
\textbf{\underline{Recursive Function for $H(n)$:}} \\
\[P(n): somethinghere\]
\textbf{\underline{Claim:}} proveouterloop
\begin{proof}
\leavevmode\\
    wordsgohere \\
\end{proof}
\leavevmode\\
\textbf{\underline{Closed Form for $H$ (Using Repeated Substitution):}} \\
\\
\textbf{XII} \\
Consider the following function:
\begin{lstlisting}
    def fast_rec_mult(x, y):
    n = length of x  # Assume x and y have the same length
    if n == 1:
        return x * y
    else:
        a = x // 10^(n // 2)
        b = x % 10^(n // 2)
        c = y // 10^(n // 2)
        d = y % 10^(n // 2)
        p = fast_rec_mult(a + b, c + d)
        r = fast_rec_mult(a, c)
        u = fast_rec_mult(b, d)

        return r * 10^n + (p - r + u) * 10^(n // 2) + u
\end{lstlisting}
\textbf{\underline{Worst-Case Runtime Analysis:}} \\
wordsgohere
\\
\textbf{XIV} \\
Recall the recurrence for the worst-case runtime of quicksort:
\[ \begin{dcases}
    c, &\text{ if } n \leq 1; \\
    T(|L|) + T(|G|) + dn, &\text{ if } n > 1.
\end{dcases}
\] where $L$ and $G$ are the partitions of the list. \\
\\
For simplicity, ignore that each list has size \(\frac{n-1}{2}\). \\
\\
\textbf{(a):} Assume the lists are always evenly split; that is, \(|L| = |G| = \frac{n}{2}\) at each recursive call. \\
\textbf{\underline{Tight Asymptotic Bound on the Runtime of Quicksort:}} \\
determinehere \\
\\
\textbf{(b):} Assume the lists are always very unevenly split; that is, \(|L| = n - 2\) and \(|G| = 1\) at each recursive call. \\
\textbf{\underline{Tight Asymptotic Bound on the Runtime of Quicksort:}} \\
determinehere \\
\\
\end{document}
