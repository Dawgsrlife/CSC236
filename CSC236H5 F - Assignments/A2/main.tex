\documentclass[12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{newunicodechar}
\newunicodechar{‚Ñù}{\mathbb{R}}
\usepackage{EngReport}
\usepackage{listings}
\usepackage{cancel}
\usepackage{comment}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{geometry}
\usepackage{xcolor}  % Required for coloring in listings

\graphicspath{{Images/}}
\onehalfspacing
\geometry{letterpaper, portrait, includeheadfoot=true, hmargin=1in, vmargin=1in}

% Define custom colors
\definecolor{myblue}{RGB}{0, 128, 255}
\definecolor{mygreen}{RGB}{34, 139, 34}
\definecolor{myorange}{RGB}{255, 140, 0}
\definecolor{mygray}{RGB}{128, 128, 128}
\definecolor{mypurple}{RGB}{148, 0, 211}
\definecolor{myred}{RGB}{255, 69, 0}

% Configure listings for Python with custom styles
\lstset{
    language=Python,             % Set language to Python
    basicstyle=\ttfamily\small,  % Use a smaller monospace font
    keywordstyle=\color{myblue}\bfseries,  % Keywords in blue and bold
    commentstyle=\color{mygreen}\itshape,  % Comments in green and italic
    stringstyle=\color{myorange},          % Strings in orange
    numberstyle=\color{mygray},            % Line numbers in gray
    identifierstyle=\color{mypurple},      % Functions and variables in purple
    morekeywords={print, len, range},      % Define additional Python keywords
    showstringspaces=false,                % Do not show spaces in strings
    breaklines=true,                       % Enable line breaking
    numbers=left,                          % Add line numbers to the left
    numbersep=5pt,                         % Space between line numbers and code
    frame=single,                          % Add a box around the code
    rulecolor=\color{mygray},              % Frame color
    moredelim=[is][\color{myred}]{@@}{@@}, % Custom inline LaTeX coloring
}

\begin{document}
\renewcommand{\familydefault}{\rmdefault}

\input{titlepage}
\input{headerfooter}
\pagebreak
\normalsize

\section*{Question \#1}
Consider the following program from pg. 53-54 of the course textbook:
\begin{lstlisting}
def avg(A):
    """
    Pre: A is a non-empty list
    Post: Returns the average of the numbers in A
    """
    sum = 0
    i = 0
    while i < len(A):
        sum += A[i]
        i += 1
    return sum / len(A)

print(avg([1, 2, 3, 4]))  # Example usage
\end{lstlisting}
Denote the predicate:
\[
Q(j): \text{At the beginning of the } j^{\text{th}} \text{ iteration, } \texttt{sum}_j = \sum_{k=0}^{i_j-1} A[k].
\]
\textbf{\underline{Claim:}} \\
$\forall j \in \{1, \dots, len(A)\}, Q(j)$
\begin{proof}
\leavevmode\\
    This proof leverages the Principle of Simple Induction. \\
    \\
    \underline{Base Case:} \\
    Let $j = 1$. \\
    At the beginning of the $1^{\text{st}}$ iteration, $\texttt{sum}_1 = 0$ and $i_1 = 0$. \\
    \\
    It follows that
    \[
    \texttt{sum}_1 = \sum_{k=0}^{i_1-1} A[k]
    = \sum_{k=0}^{0-1} A[k]
    = \sum_{k=0}^{-1} A[k]
    = 0\text{.}
    \]
    Hence, \(Q(1)\). \\
    \\
    \underline{Induction Hypothesis:} \\
    Assume for some iteration $m \in \{ 1, ..., len(A) - 1 \}$, $Q(m)$. \\
    \\
    Namely, for the $m^{\text{th}}$ iteration,
    \[\texttt{sum}_m = \sum_{k = 0}^{i_m - 1} A[k] \text{.}\]
    \\
    \underline{Induction Step:} \\
    Proceed to show \(Q(m + 1)\): \\
    \\
    Notice that \(\texttt{sum}_{m + 1} = \texttt{sum}_m + A[i_{m + 1}]\), by \textit{Line 9} of the program. \\
    \\
    By the Induction Hypothesis,
    \[
    \texttt{sum}_m + A[i_{m + 1}]
    = \sum_{k = 0}^{i_m - 1} A[k] + A[i_{m + 1}] \text{,}
    \]
    and by \textit{Line 10} of the program, \(i_{m + 1} = i_m + 1\);
    \[
    \sum_{k = 0}^{i_m - 1} A[k] + A[i_{m + 1}]
    = \sum_{k = 0}^{i_{m + 1} - 1} A[k] \text{.}
    \]
    Thus,
    \[
    \texttt{sum}_{m + 1} = \sum_{k = 0}^{i_{m + 1} - 1} A[k]
    \]
    as needed. \\
    \\
    Therefore, by the Principle of Simple Induction, $Q(j)$ holds for all $j \in \{1, \dots, len(A)\}$. \\
\end{proof}
\pagebreak
\section*{Question \#2}
Recall \(Q(j)\) from \textit{Question \# 1}: \\
\[
Q(j): \text{At the beginning of the } j^{\text{th}} \text{ iteration, } \texttt{sum}_j = \sum_{k=0}^{i_j-1} A[k].
\]
\\
Denote the following predicate:
\[
    Q'(n): 0 \leq n < len(A) \implies Q(n + 1)
\]
\textbf{\underline{Claim:}} \\
Proving $\forall j \in \{ 1, \dots, len(A) \}, Q(j)$ is equivalent to proving $\forall n \in \mathbb{N}, Q'(n)$.

\begin{proof}
\leavevmode\\
    \underline{Remarks} \\
    It is sufficient to show that $\forall j \in \{ 1, \dots, len(A) \}, Q(j) \iff \forall n \in \mathbb{N}, Q'(n)$, to show that proving one of these statements is equivalent to proving the other. \\
    \\
    \underline{$(\forall j \in \{ 1, \dots, len(A) \}, Q(j)) \implies (\forall n \in \mathbb{N}, Q'(n))$:} \\
    Suppose $\forall j \in \{ 1, \dots, len(A) \}, Q(j)$. \\
    \\
    Then, fix $n \in \mathbb{N}$ and suppose $0 \leq n <  len(A)$. \\
    \\
    Because $n \in \{0, ..., len(A) - 1\}$, it follows that $(n + 1) \in \{ 1, \dots, len(A) \} $. \\
    \\
    By assumption, $Q(n + 1)$. \\
    \\
    Thus, $\forall n \in \mathbb{N}, Q'(n)$. \\
    \\
    \underline{$(\forall j \in \{ 1, \dots, len(A) \}, Q(j)) \impliedby (\forall n \in \mathbb{N}, Q'(n))$:} \\
    Suppose $\forall n \in \mathbb{N}, Q'(n)$. \\
    \\
    Let $j \in \{ 1, \dots, len(A) \}$. \\
    \\
    Then, $(j - 1) \in \mathbb{N}$. \\
    \\
    It follows that $0 \leq j - 1 \leq len(A) - 1$. \\
    \\
    Since $len(A) - 1 < len(A)$, $0 \leq j - 1 < len(A)$. \\
    \\
    By assumption, $Q((j - 1) + 1)$. \\
    \\
    Thus, $\forall j \in \{1, \dots, len(A)\}, Q(j)$. \\
    \\
    \underline{Conclusion:} \\
    Therefore, $\forall j \in \{ 1, \dots, len(A) \}, Q(j) \iff \forall j \in \mathbb{N}, Q'(n)$. \\
\end{proof}
\pagebreak
\section*{Question \#3}
As follows below, Q6-Q10 respectively represent questions 6 through 10 from pp. 64-66 of the course textbook. \\
\\
\textbf{Q6:} \\
Consider the following code:
\begin{lstlisting}
def f(x):
    """Pre: x is a natural number"""
    a = x
    y = 10
    while a > 0:
        a -= y
        y -= 1
    return a * y
\end{lstlisting}
\underline{\textbf{(a):} Loop Invariant Which Characterizes \texttt{a} and \texttt{y}:} \\
For arbitrary natural n... \\
Let $i_1 = 0$ and $i_n = i_{n-1} + 1$. \\
Let $y_n$ be the value of $y$ before the $(n + 1){\text{th}}$ iteration. By \textit{Line 4} (initializes $y = 10$) and \textit{Line 7} (decrements $y$ by $1$) of the program, $y_n = 10 - \sum_{q = 1}^{n} 1 = 10 - n \times 1 = 10 - n$. \\
Denote the loop invariant: \\
\[
P(j): (a_j = x - \sum_{k = 0}^{i_j - 1} y_k) \land (y_j = 10 - j)
\]
\\
For example, before the $1^{\text{st}}$ iteration, $a_1 = x - \sum_{k = 0}^{i_1 - 1} y_k = x - \sum_{k = 0}^{0 - 1} y_k = x - 0 = x$. \\
\\
Before the $2^{\text{nd}}$ iteration, $a_2 = x - \sum_{k = 0}^{i_2 - 1} y_k = x - \sum_{k = 0}^{1 - 1} y_k = x - y_0 = x - 10$. \\
\\
\underline{\textbf{(b):} Why This Function Fails to Terminate} \\
Suppose $x > \sum_{k=1}^{10} k = 55$. \\
\\
By $P(j)$, before the $11^{\text{th}}$ iteration, $a_{11} = x - \sum_{k = 0}^{i_{11} - 1} y_k = x - \sum_{k = 0}^{10 - 1} y_k = x - \sum_{k = 0}^{9} (10 - k) = x - [10\sum_{k = 0}^{9} (1) - \sum_{k = 0}^{9} (k)] = x - [10(10) - \frac{9(9 + 1)}{2}] = x - [100 - 45] = x - 55$. \\
\\
Since $x > 55$, it follows that $a_{11} = x - 55 > 0$. \\
\\
As well, $y_{10}$ (the value of $y$ after the $11^{\text{th}}$ iteration) is $10 - 11 = -1$. \\
\\
Notice that in all subsequent iterations, $a$ will decrement by $y_n < 0 |_{n \geq 11}$ (where $n$ is the iteration number of the corresponding iteration). \\
\\
Since $a$ decrements by a negative number subsequently, the loop causes $a$ to grow large, thereby retaining $a > 0$. \\
\\
Thus, the function fails to terminate for $x > 55$ (because $\neg (a > 0)$ is never satisfied). \\
\\
\textbf{Q7:} \\
\textbf{(a)} Consider the recursive program below:
\begin{lstlisting}
def exp_rec(a, b):
    if b == 0:
        return 1
    else if b mod 2 == 0:
        x = exp_rec(a, b / 2)
        return x * x
    else:
        x = exp_rec(a, (b - 1) / 2)
        return x * x * a
\end{lstlisting}
\underline{Preconditions:}
\[
    (b \in \mathbb{N}) \land (a \neq 0)
\]
\underline{Postconditions:}
\[
    \text{Returns } a^b \text{.}
\]
Denote the following predicate:
\[P(b): \text{The program returns } a^b \text{.}\]
\textbf{\underline{Claim:}} \(\forall b \in \mathbb{N}, P(b)\) 
\begin{proof}
\leavevmode\\
    This proof explores the Principle of Complete Induction on $b$. \\
    \\
    Fix $a \neq 0$. \\
    \\
    \underline{Base Case:} \\
    Let $b = 0$. \\
    \\
    Then, by \textit{Lines 2-3} of the program, the program returns $1 = a^0 = a^b$. \\
    \\
    Hence, $P(0)$. \\
    \\
    \underline{Induction Hypothesis:} \\
    Assume for some \(k \in \mathbb{N}\) and for all \(l \in [0, k] \cap \mathbb{N}\), \(P(l)\). \\
    \\
    This means the program returns $a^l$ for every $l$ as described. \\
    \\
    \underline{Induction Step:} \\
    Proceed to show \(P(k + 1)\) with case analysis: \\
    \\
    \textit{Case 1 - Suppose $(k + 1) (\text{mod } 2) \not\equiv 0$:} \\
    Then, program again enters the \texttt{else} statement in \textit{Line 7}. \\
    \\
    Here, the program sets $x$ to \verb|exp_rec(a, ((k + 1) - 1) / 2)|. \\
    \\
    Notice that \(\verb|exp_rec(a, ((k + 1) - 1) / 2)| = \verb|exp_rec(a, (k / 2))|\). \\
    \\
    Since $(k + 1)(\text{mod } 2) \not\equiv 0$, it must be that $k (\text{mod 2} \equiv 0)$. \\
    \\
    Thus, $\frac{k}{2} \in \mathbb{N}$ and $\frac{k}{2} < k$. \\ 
    \\
    By the Induction Hypothesis, \verb|exp_rec(a, k / 2)| returns $a^{\frac{k}{2}}$. \\
    \\
    Finally, the original function call returns $x \times x \times a$, which evaluates to $a^{\frac{k}{2}} \times a^{\frac{k}{2}} \times a = a^{\frac{k}{2} + \frac{k}{2} + 1} = a^{k + 1}$, as needed. \\
    \\
    Thus, $P(k + 1)$ holds. \\
    \\
    \textit{Case 2 - Suppose $(k + 1) (\text{mod } 2) \equiv 0$:} \\
    Then, the program reaches \textit{Line 5} and sets $x$ to \verb|exp_rec(a, (k + 1) / 2)|. \\
    \\
    Notice that $\frac{k + 1}{2} \in \mathbb{N}$ and $\frac{k + 1}{2} \leq k$. \\
    \\
    By the Induction Hypothesis, \verb|exp_rec(a, (k + 1) / 2)| returns $a^{\frac{k + 1}{2}}$. \\
    \\
    Finally, the original function call returns $x \times x$, evaluating to $a^{\frac{k + 1}{2}} \times a^{\frac{k + 1}{2}} = a^{\frac{k + 1}{2} + \frac{k + 1}{2}} = a^{k + 1}$, as needed. \\
    \\
    Thus, P(k + 1) holds. \\
    \\
    \underline{Conclusion:} \\
    Therefore, $P(k + 1)$ holds in all cases. \\
    \\
    By the Principle of Complete Induction, $\forall b \in \mathbb{N}, P(b)$. \\
\end{proof}
\leavevmode\\
\textbf{(b)} Consider the iterative version of the previous program:
\begin{lstlisting}
def exp_iter(a, b):
    ans = 1
    mult = a
    exp = b
    while exp > 0:
        if exp mod 2 == 1:
            ans *= mult
        mult = mult * mult
        exp = exp // 2
    return ans
\end{lstlisting}
\underline{Preconditions:}
\[
    (b \in \mathbb{N}) \land (a \neq 0)
\]
\underline{Postconditions:}
\[
    \text{Returns } a^b \text{.}
\]
\textbf{\underline{Claim:}} For all natural $b$, the program returns $a^b$ and terminates.
\begin{proof}
\leavevmode\\
    Fix $a \neq 0$ and $b \in \mathbb{N}$. \\
    \\
    \underline{Loop Invariant Proof:} \\
    Denote the Loop Invariant:
    \[P(i): a^b = \verb|mult|_i^{\verb|exp|_i} \times \verb|ans|_i \]
    To prove the loop invariant, this proof explores the Principle of Simple Induction on $i \in [1, \lfloor log_2b \rfloor + 2] \cap \mathbb{N}$. \\
    \\
    \underline{Base Case:} \\
    Let $i = 1$. \\
    \\
    Then, the program retains the values $\verb|mult|_1 = a$, $\verb|exp|_1 = b$, $\verb|ans_1 = 1|$. \\
    \\
    Notice that $a^b = a^b \times 1 = \verb|mult|_1^{\verb|exp|_1} \times \verb|ans|_1$. \\
    \\
    Hence, at the beginning of the $1^{\text{st}}$ iteration, $P(1)$. \\
    \\
    \underline{Induction Hypothesis:} \\
    Assume for some $k \in [1, \lfloor log_2b \rfloor + 1] \cap \mathbb{N}, P(k)$;
    \[
        P(k): (a^b = \verb|mult|_k^{\verb|exp|_k} \times \verb|ans|_k) \text{.}
    \]
    \underline{Induction Step:} \\
    Notice that $\verb|exp|_k = \lfloor \frac{b}{2^{k - 1}} \rfloor$. \\
    \\
    Because $k - 1 \leq \lfloor log_2b \rfloor$, then $2^{k - 1} \leq 2^{\lfloor log_2b \rfloor} \leq 2^{log_2b} = b$. \\
    \\
    Therefore, it follows that \(\frac{b}{2^{k - 1}} \geq 1\). \\
    \\
    Thus, $\verb|exp|_k = \lfloor \frac{b}{2^{k - 1}} \rfloor \geq 1$, and the following iteration runs. \\
    \\
    Then, the program yields the following values:
    \[
    \left\{
    \begin{array}{ll}
    \verb|mult|_{k + 1} = \verb|mult|_k \times \verb|mult|_k = \verb|mult|_k^2, & \hspace{1cm} \text{by \textit{Line 8}} \\
    \verb|exp|_{k + 1} = \left\lfloor \frac{\texttt{exp}_k}{2} \right\rfloor, & \hspace{1cm} \text{by \textit{Line 9}}
    \end{array}
    \right.
    \]
    \\
    Notice that \(\verb|mult|_{k + 1}^{\verb|exp|_{k + 1}} = (\verb|mult|_k^2)^{\lfloor \frac{\texttt{exp}_k}{2} \rfloor} = \verb|mult|_k^{2 \lfloor \frac{\texttt{exp}_k}{2} \rfloor}\). \\
    \\
    Proceed to show $P(k + 1)$ with case analysis: \\
    \\
    \underline{\textit{Case 1 - Suppose \(exp_k (\text{mod } 2) \equiv 1\):}} \\
    By \textit{Lines 6-7} of the program, \(\verb|ans|_{k + 1} = \verb|ans|_k \times \verb|mult|_k\). \\
    \\
    So, \((\verb|mult|_{k + 1}^{\verb|exp|_{k + 1}}) \times (\verb|ans|_{k + 1}) = (\verb|mult|_k^{2 \lfloor \frac{\texttt{exp}_k}{2} \rfloor}) \times (\verb|ans|_k \times \verb|mult|_k)\). \\
    \\
    Since \(\verb|exp|_k (\text{mod } 2) \equiv 1\), it follows that \(2 \lfloor \frac{\texttt{exp}_k}{2} \rfloor = \cancel{2} (\frac{\texttt{exp}_k - 1}{\cancel{2}}) = \verb|exp|_k - 1\). \\
    \\
    Thus,
    \begin{equation*}
        \begin{aligned}
            (\verb|mult|_k^{2 \lfloor \frac{\texttt{exp}_k}{2} \rfloor}) \times (\verb|ans|_k \times \verb|mult|_k) &= (\verb|mult|_k^{\verb|exp|_k - 1}) \times (\verb|mult|_k \times \verb|ans|_k) \\
            &= \verb|mult|_k^{\verb|exp|_k - 1} \times \verb|mult|_k \times \verb|ans|_k \\
            &= (\verb|mult|_k^{\verb|exp|_k - 1} \times \verb|mult|_k) \times \verb|ans|_k \\
            &= (\verb|mult|_k^{(\verb|exp|_k - 1) + 1}) \times \verb|ans|_k \\
            &= \verb|mult|_k^{\verb|exp|_k} \times \verb|ans|_k \\
            &= a^b \text{,}
        \end{aligned}
    \end{equation*}
    by the Induction Hypothesis.
    \\
    Therefore, \((\verb|mult|_{k + 1}^{\verb|exp|_{k + 1}}) \times (\verb|ans|_{k + 1}) = a^b\); $P(k + 1)$ holds. \\
    \\
    \underline{\textit{Case 2 - Suppose \(exp_k (\text{mod } 2) \not\equiv 1\):}} \\
    By \textit{Line 6} of the program, \textit{Line 7} does not run. \\
    \\
    Hence, $\verb|ans|_{k + 1}$ retains the value as represented by $\verb|ans|_k$; \(\verb|ans|_{k + 1} = \verb|ans|_k\). \\
    \\
    So, \((\verb|mult|_{k + 1}^{\verb|exp|_{k + 1}}) \times (\verb|ans|_{k + 1}) = (\verb|mult|_k^{2 \lfloor \frac{\texttt{exp}_k}{2} \rfloor}) \times \verb|ans|_k\). \\
    \\
    Notice that \(\verb|exp|_k (\text{mod } 2) \not\equiv 1 \iff \verb|exp|_k (\text{mod } 2) \equiv 0\). \\
    \\
    So, \(2 \lfloor \frac{\texttt{exp}_k}{2} \rfloor = \cancel{2} (\frac{\texttt{exp}_k}{\cancel{2}}) = \verb|exp|_k\). \\
    \\
    Then, it follows that \((\verb|mult|_k^{2 \lfloor \frac{\texttt{exp}_k}{2} \rfloor}) \times \verb|ans|_k = (\verb|mult|_k^{\verb|exp|_k}) \times \verb|ans|_k = a^b\), by the Induction Hypothesis. \\
    \\
    Still, \((\verb|mult|_{k + 1}^{\verb|exp|_{k + 1}}) \times (\verb|ans|_{k + 1}) = a^b\); $P(k + 1)$ likewise holds. \\
    \\
    \underline{Conclusion of Loop Invariant Proof:} \\
    Collectively, $P(k + 1)$ holds in all cases. \\
    \\
    By the Principle of Simple Induction, $P(i)$ holds for all $i \in [1, \lfloor log_2b \rfloor + 2]$. \\
    \\
    \underline{Program Termination Proof} \\
    Notice that \textit{Line 9} of the program performs floor division by $2$ on \texttt{exp} in each iteration. \\
    \\
    From continual division, \texttt{exp} eventually becomes small enough that it reaches $0$ through the next floor division by $2$. \\
    \\
    Since the program's loop requires $\texttt{exp} > 0$ to run, having \texttt{exp} reach $0$ indeed terminates the loop. \\
    \\
    \underline{Conclusion:} \\
    Therefore, this program is both correct (by the loop invariant) and terminates. \\
\end{proof}
\leavevmode\\
\textbf{Q8} \\
Consider the following linear time program:
\begin{lstlisting}
def majority(A):
    """
    Pre: A is a list with more than half its entries equal to x
    Post: Returns the majority element x
    """
    c = 1
    m = A[0]
    i = 1
    while i <= len(a) - 1:
        if c == 0:
            m = A[i]
            c = 1
        else if A[i] == m:
            c += 1
        else:
            c -= 1
        i += 1
    return m
\end{lstlisting}
\textbf{\underline{Claim:}} For all lists $A$ with more than half its entries equal to $x$, the program returns the majority element $x$ and terminates. \\
\begin{proof}
\leavevmode\\
    For simplicity, express ``\texttt{List} has more than half its entries equal to $x$'' by ``\texttt{List} is valid,'' and its complement by ``\texttt{List} is NOT valid.''\\
    \\
    Let $v_n$ represent the difference between the count of $x$ and the count of elements that are not $x$ in sublist $A[0:n]$, before the $n^{\text{th}}$ iteration. \\
    \\
    \underline{Loop Invariant Proof:} \\
    Denote the Loop Invariant:
    \begin{center}
        \(P(i):\)
        \[((A[0:i] \text{ is valid}) \implies ((m_i = x) \land (c_i \geq v_i)))\]
        \[\land\]
        \[((A[0:i] \text{ is NOT valid}) \implies ((m_i = x) \lor (c_i \leq -v_i)))\]
    \end{center}
    To prove the loop invariant, this proof explores the Principle of Simple Induction on $i \in [1, len(a)]$. \\
    \\    
    \underline{Base Case:} \\
    Let $i = 1$. \\
    \\
    Then, $A[0:i] = A[0:1] = [A[0]] = [x]$, by the precondition. \\
    \\
    With the sole element being $x$, $A[0:i]$ is valid. \\
    \\
    Notice that \textit{Line 7} of the program sets $m_1$ to $A[0] = x$, and $c_1 = 1 = v_1$. \\
    \\
    Thus, $m_1 = x$ and $c_1 \geq v_1$; $P(1)$ holds. \\
    \\
    \underline{Induction Hypothesis:} \\
    \\
    Assume for some $k \in [1, len(a) - 1]$, $P(k)$:
    \begin{center}
        \(P(k):\)
        \[((A[0:k] \text{ is valid}) \implies ((m_k = x) \land (c_k \geq v_k)))\]
        \[\land\]
        \[((A[0:k] \text{ is NOT valid}) \implies ((m_k = x) \lor (c_k \leq -v_k)))\]
    \end{center}
    \underline{Induction Step:} \\
    Consider the following cases... \\
    \\
    \underline{\textit{Suppose $A[0:k + 1]$ is valid:}} \\
    By the Induction Hypothesis, $m_k = x$ and $c_k \geq v_k$. \\
    \\
    Notice that $v_k > 0$ because $A[0:k + 1]$ is valid (the sublist has more entries of $x$ than entires of not $x$). \\
    \\
    It follows that $c_k \geq v_k > 0$, so $c \neq 0$. \\
    \\
    When the iteration runs, the program does not enter \textit{Lines 10-12}. \\
    \\
    So, $m_{k + 1}$ retains the value of $m_k = x$, and $CONTINUE HERE!!!$. \\
    \\
    \underline{\textit{Suppose $A[0:k + 1]$ is NOT valid:}} \\
    \\
    \underline{Conclusion of Loop Invariant Proof} \\
    \\
    wordsgohere \\
    \\
    \underline{Program Termination Proof:} \\
    \\
    wordsgohere \\
    \\
    \underline{Conclusion:} \\
    \\
    wordsgohere \\
\end{proof}
\leavevmode\\
\textbf{Q9} \\
Consider the bubblesort algorithm as follows:
\begin{lstlisting}
def bubblesort(L):
    """
    Pre: L is a list of numbers
    Post: L is sorted
    """
    k = 0
    while k < len(L):
        i = 0
        while i < len(L) - k - 1:
            if L[i] > L[i + 1]:
                swap L[i] and L[i + 1]
            i += 1
        k += 1
\end{lstlisting}
\textbf{(a):} Denote the inner loop's invariant:
\[P(j): (\forall i \in [0, j - 1] \cap \mathbb{N})(L[i] \leq L[j])\]
\textbf{\underline{Claim:}} At the start of all iterations $j \in [1, len(L) - k] \cap \mathbb{N}$, $P(j)$.
\begin{proof}
\leavevmode\\
    \underline{Base Case:} \\
    Let $j = 1$. Then, $i \in [0, 1 - 1] \cap \mathbb{N}$. \\
    \\
    Then, $i = 0$. \\
    \\
    Notice that $L[0] \leq L[1]$, by \textit{Lines 10-11} of the program (if this is not satisfied, the elements are swapped so that it is). \\
    \\
    Thus, $P(1)$. \\
    \\
    \underline{Induction Hypothesis:} \\
    Assume for some $k \in [1, len(L) - k - 1] \cap \mathbb{N}$, $P(k)$ holds. \\
    \\
    This means, $(\forall i \in [0, k - 1] \cap \mathbb{N})(L[i] \leq L[k])$. \\
    \\
    \underline{Induction Step:} \\
    Suppose $L[j] \leq L[j + 1]$. \\
    \\
    Then, no swaps are made and $P(j + 1)$ immediately holds by the Induction Hypothesis. \\
    \\
    So, consider $L[j] > L[j + 1]$. \\
    \\
    By \textit{Lines 10-11} of the program, the two elements are swapped. \\
    \\
    The result is $L[j] \leq L[j + 1]$ before the $(j + 1)^{\text{th}}$ iteration, and $P(j + 1)$ likewise holds by the Induction Hypothesis. \\
\end{proof}
\leavevmode\\
\textbf{(b):} Denote the outer loop's invariant:
\[Q(n): L[len(L) - n:] \text{ is sorted.}\]
\textbf{\underline{Claim:}} At the start of all iterations $n \in [1, len(L)]$, $Q(n)$.
\begin{proof}
\leavevmode\\
    \underline{Base Case:} \\
    Let $n = 1$. \\
    \\
    Then, $L[len(L) - n:] = L[len(L) - 1:]$ is a sublist of $L$ containing only the last element of $L$. \\
    \\
    Vacuously, this list is indeed sorted, so $Q(1)$. \\
    \\
    \underline{Induction Hypothesis:} \\
    Assume for some $m \in [1, len(L)]$, $Q(m)$. \\
    \\
    This means $L[len(L) - m:]$ is sorted. \\
    \\
    \underline{Induction Step:} \\
    By the inner loop of the program $(\forall i \in [0, m - 1] \cap \mathbb{N})(L[i] \leq L[m])$. \\
    \\
    This means, there is no element larger than $L[len(L) - m]$ for elements in indices less than $len(L) - m$. \\
    \\
    The inner loop places this large value at $L[len(L) - m]$. \\
    \\
    By the Induction Hypothesis, $L[len(L) - m:]$ is sorted. \\
    \\
    In the subsequent iteration, the program's inner loop grabs a new element from the pool of elements not larger than $L[len(L) - m]$ (from the smaller indices). \\
    \\
    This inner loop places this new large value at $L[len(L) - (m + 1)]$. \\
    \\
    Since this $L[len(L) - (m + 1)]$ is not larger than $L[len(L) - m]$, and because $L[len(L) - m:]$ is sorted, $L[len(L) - (m + 1):]$ is updated as a sorted sublist. \\
    \\
    Thus, $Q(m + 1)$. \\
\end{proof}
\leavevmode\\
\textbf{(c):}
\textbf{\underline{Claim:}} If $L$ is a list of numbers, then the program returns $L$ as a sorted list. \\
\begin{proof}
\leavevmode\\
    To show that this program is correct, it remains to show that the inner and outer loops both terminate, since their invariants are proven. \\
    \\
    \underline{Inner Loop Termination:} \\
    To show that the inner loop terminates, consider the loop variant $Var = len(L) - k - i$. \\
    \\
    Denote $\widetilde{Var}$ as the loop variant in the subsequent iteration. \\
    \\
    Then, notice that $\widetilde{Var} = len(L) - k - (i + 1) < len(L) - k - i = Var$. \\
    \\
    Since $len(L), k, i \in \mathbb{N}$, and the variant decreases in subsequent iterations, the inner loop indeed terminates. \\
    \\
    \underline{Outer Loop Termination:} \\
    To show that the outer loop terminates, consider the loop invariant $Var = len(L) - i$. \\
    \\
    Denote $\widetilde{Var}$ as the loop variant in the subsequent iteration. \\
    \\
    Then, notice that $\widetilde{Var} = len(L) - (i + 1) < len(L) - i = Var$. \\
    \\
    Likewise, since $len(L), i \in \mathbb{N}$, and the invariant decreases in subsequent iterations, the outer loopp terminates as well. \\
    \\
    \underline{Conclusion:} \\
    Therefore, because both the inner and outer loop are correct and terminate, the program correctly takes any list of numbers $L$ and returns its corresponding sorted list. \\
\end{proof}
\leavevmode\\
\textbf{Q10} \\
Consider the following generalization of the \texttt{min} function:
\begin{lstlisting}
def extract(A, k):
    pivot = A[0]
    # Use partition from quicksort
    L, G = partition(A[1, ..., len(A) - 1], pivot)
    if len(L) == k - 1:
        return pivot
    else if len(L) >= k:
        return extract(L, k)
    else:
        return extract(G, k - len(L) - 1)
\end{lstlisting}
\textbf{(a):} Proof of Correctness \\
\underline{Preconditions:}
\[A \text{ is a list of numbers such that } len(A) \geq 1 \text{, and } k \in [1, len(A)] \cap \mathbb{N} \text{.}\]
\underline{Postconditions:}
\[\text{Returns the } k^{\text{th}} \text{ smallest element of } A \text{.}\]
Denote the following predicate:
\[P(n): \text{The program returns the } 1 \leq k^{\text{th}} \leq n \text{ smallest element from the list } A \text{ of size } n \text{.}\]
\textbf{\underline{Claim:}} For any list $A$ of length $n = len(A) \geq 1$, $P(n)$ holds.
\begin{proof}
\leavevmode\\
    This proof explores the Principle of Complete Induction on $n$. \\
    \\
    Fix $k \in [1, n] \cap \mathbb{N}$. \\
    \\
    \underline{Base Case:} \\
    Let $A$ be a list of length $n = len(A) = 1$.
    \\
    Then, $A$ is a list containing one element, and $k = 1$ (representing the \textit{first smallest} element of $A$) is the only value of $k$. \\
    \\
    By \textit{Line 2} of the program, $\texttt{pivot} = A[0]$. \\
    \\
    Because \texttt{pivot} is an element of $A$, the precondition for the function $partition(A, \texttt{pivot})$ is satisfied. \\
    \\
    So, assume the corresponding postcondition of $partition(A, \texttt{pivot})$:
    \begin{center}
        $L$ contains the elements of $A$ less than the pivot, \\
        and $G$ contains the elements greater than the pivot.
    \end{center}
    With no other elements to compare with, both $L$ and $G$ will be empty. \\
    \\
    In \textit{Line 5} of the program, notice that $len(L) == k - 1$ holds as $len(L) = 0 = (1) - 1$. \\
    \\
    Therefore, the program enters \textit{Line 6} and returns \texttt{pivot}. \\
    \\
    As the sole and smallest element of $A$, returning \texttt{pivot} indeed returns the $1^{\text{st}}$ smallest element of $A$. \\
    \\
    Thus, $P(1)$. \\
    \\
    \underline{Induction Hypothesis:} \\
    Assume for all lists $A$ of length $j \in [1, i] \cap \mathbb{N}$, for some $i \geq 1$ and $k \in [1, j] \cap \mathbb{N}$, $P(j)$ holds. \\
    \\
    This means all lists $A_1, A_2, \dots, A_i$ passed into $extract(A, k)$ result in $extract(A, k)$ returning the $k_1^{\text{th}}$ or $k_2^{\text{th}}$ or $\dots$ or $k_i^{\text{th}}$ corresponding smallest element from the corresponding list. \\
    \\
    \underline{Induction Step:} \\
    Assume the algorithm is correct for all lists of length $j \in [1, i] \cap \mathbb{N}$ for some $i \geq 1$ and $k \in [1, j] \cap \mathbb{N}$. \\
    \\
    To show $P(1), P(2), \dots, P(i) \implies P(i + 1)$, it is necessary to show that the function algorithm is correct for all lists of size $i + 1$ and $k \in [1, i + 1] \cap \mathbb{N}$ for some $i \geq 1$ and $k \in [1, j] \cap \mathbb{N}$, while assuming the preconditions hold on the function call. \\
    \\
    Notice that the program sets \texttt{pivot} to $A[0]$, the first element in $A$. \\
    \\
    So, \texttt{pivot} represents an element of $A$, satisfying the precondition for the $partition$ function. \\
    \\
    $partition$ then returns $L$ and $G$, which are lists containing all elements less than the pivot and greater than the pivot, respectively. \\
    \\
    Consider the following cases... \\
    \\
    \underline{\textit{Suppose $len(L) = k - 1$:}} \\
    Then, there are $k - 1$ elements smaller than the pivot, by the postcondition of $partition$. \\
    \\
    Therefore, \texttt{pivot} must be the $k^{\text{th}}$ smallest element in $A$. \\
    \\
    The program enters \textit{Line 6} and returns \texttt{pivot}. \\
    \\
    Thus, $P(i + 1)$. \\
    \\
    \underline{\textit{Suppose $len(L) \geq k$:}} \\
    Then, $L$ has enough elements to contain the $k^{\text{th}}$ smallest element in $A$, so the $k^{\text{th}}$ smallest element in $A$ must be in $L$. \\
    \\
    Notice, additionally, that \texttt{pivot} is not the $k^{\text{th}}$ smallest element. \\
    \\
    Then, the program reaches \textit{Line 8}, returning $extract(L, k)$. \\
    \\
    Notice that $L$ is a list with $len(L) \geq 1$, and $k \in [1, len(L)] \cap \mathbb{N}$. \\
    \\
    Then, by the Induction Hypothesis (as $len(L) < len(A)$), $extract(L, k)$ correctly returns the $k^{\text{th}}$ smallest element in the list $L$. \\
    \\
    Thus, $P(i + 1)$. \\
    \\
    \underline{\textit{Suppose $len(L) < k - 1$:}} \\
    Then, $L$ does not have enough elements to contain the $k^{\text{th}}$ smallest element in $A$, so the $k^{\text{th}}$ smallest element in $A$ must be $G$. \\
    \\
    Again, \texttt{pivot} is not the $k^{\text{th}}$ smallest element. \\
    \\
    Then, the program reaches \textit{Line 10}, returning $extract(G, k - len(L) - 1)$. \\
    \\
    Notice that the $(k - len(L) - 1)^{\text{th}}$ smallest element in $G$ is the smallest element in $A$ (exclude the number of elements in $L$ and \texttt{pivot}). \\
    \\
    Notice that $G$ is a list with $len(G) \geq 1$, and $(k - len(L) - 1) \in [1, len(G)] \cap \mathbb{N}$. \\
    \\
    Then, by the Induction Hypothesis (as $len(G) < len(A)$), $extract(G, k - len(L) - 1)$ correctly returns the $(k - len(L) - 1)^{\text{th}}$ smallest element in the list $G$. \\
    \\
    Thus, $P(i + 1)$. \\
    \\
    \underline{Conclusion:} \\
    Since the Base Case $P(1)$ holds, and $P(1), P(2), \dots, P(i) \implies P(i + 1)$, by the Principle of Complete Induction, $P(n)$ holds for all lists of length $n \geq 1$. \\
    \\
    \underline{Termination Proof:} \\
    The above proof shows that each call to $extract(A, k)$ considers a sublist with a length less than the initial list passed to the function, from either a previous call up the stack or the initial call. \\
    \\
    In each recursive call case, either $L$ or $G$ is the sublist being passed. \\
    \\
    Notice that, excluding \texttt{pivot}, each of these lists are at most as long as $A$. \\
    \\
    Therefore, $len(G) \leq len(A) - 1$ and $len(L) \leq len(A) - 1$. \\
    \\
    As a note, the equalities hold when \texttt{pivot} is the smallest element in $A$ and when \texttt{pivot} is the greatest element in A, respectively. \\
    \\
    \underline{Citation:} \\
    This proof is inspired by the Tutorial 5 slides for its Problem 1 from this CSC236 course. \\
\end{proof}
\leavevmode\\
\textbf{(b):} Worst-Case Runtime \\
Denote the size of the list $A$ by $n = len(A)$. \\
\\
To find the worst-case runtime of the program, consider the program's behaviour for its base and recursive cases. \\
\\
\underline{Base Case of Program:} \\
Let n = 1. \\
\\
Then, the program reaches the $if$ block (for the reason as analysed in the above proof) and returns \texttt{pivot}. \\
\\
Exiting here, the program runs in constant time. \\
\\
\underline{Base Case of Program:} \\
Let $n > 1$. \\
\\
In quicksort partitioning, the worst case occurs when one of the lists $L, G$ is empty. \\
\\
Then, the $else if$ and $else$ blocks run, making a function call on a sublist that is $1$ size smaller than the size of the current list. \\
\\
Also, the number of recursive steps depend on the size of the current list, $n$. \\
\\
This means, the recursive case has runtime $T(n - 1) + dn$. \\
\\
Define the recurrence:
\[
    T(n) =
    \begin{cases}
        c & \text{if } n \leq 1 \\
        T(n - 1) + dn & \text{if } n > 1
    \end{cases}
\]
\\
For $n \leq 1$, $T(n) = c$, for some constant $c$, and the program runs in constant time with the tight bound $\Theta (1)$. \\
\\
Otherwise, $n > 1$; evaluate the closed form for $T(n)$ as follows:
\begin{equation*}
    \begin{aligned}
        T(n) &= T(n - 1) + dn \\
        &= T((n - 1) - 1) + [dn] \\
        &= T((n - 2) - 1) + [dn] \\
        &. \; \dots \\
        &. \; \dots \\
        &. \; \dots \\
        &= c + d(\sum_{i = 0}^{k} (n - 1))
    \end{aligned}
\end{equation*}
Through repeated substitution, $T(0)$ is eventually reached. \\
\\
Notice that every unique call of $T(n)$ has the form $T((n - k) - 1)$, for some natural $k$. \\
\\
Therefore, $T(0) = T((n - k) - 1) \implies 0 = (n - k) - 1 \implies k = n - 1$; the call of $T(0)$ occurs when $k = n - 1$. \\
\\
Continue evaluating $T(n)$ with $k = n - 1$:
\begin{equation*}
    \begin{aligned}
        T(n) &= c + d(\sum_{i = 0}^{n - 1} (n - 1)) \\
        &= d[(\sum_{i = 0}^{n - 1} n) - (n - 1)] + c \\
        &= d[(\frac{((n - 1) + 1)(n - 1)}{2}) - (n - 1)] + c \\
        &= d[(\frac{n^2 - n - 2n + 2}{2})] + c \\
        &= \frac{dn^2 - 3dn + 2c}{2}
    \end{aligned}
\end{equation*}
Thus, $T(n) = \frac{dn^2 - 3dn + 2c}{2}$ for $n > 1$. \\
\\
Notice that in this closed form, $n^2$ is the term with the highest degree, so it takes precedence. \\
\\
Therefore, the tight asymptotic bound on the runtime of the program is $\Theta (n^2)$. \\
\\
By definition, the worst-case runtime of the program is $\mathcal{O} (n^2)$. \\
\\
\underline{Final Answer:} \\
The worst-case runtime of the program is $\mathcal{O} (n^2)$. \\
\pagebreak
\section*{Question \#4}
As follows below, VI, VII, XII, and XIV respectively represent questions 6, 7, 12, and 14 from pp. 46-48 of the course textbook. \\
\\
\textbf{VI} \\
Let $T(n)$ be the number of binary strings of length $n$ where every $1$ is immediately preceded by a $0$. \\
\\
\textbf{(a):} Recurrence for $T(n)$: \\
\[
    T(n) =
    \begin{cases}
        1 & \text{if } n = 0 \\
        1 & \text{if } n = 1 \\
        T(n - 1) + T(n - 2) & \text{if } n > 2
    \end{cases}
\]
\\
\textbf{(b):} Closed Form Expression for $T(n)$: \\
Notice that $T(n)$ is equivalent to the Fibonacci sequence, shifted left by one term. \\
\\
Therefore, $T(n) = F_{n + 1}$, where $F_n$ is the $n^{\text{th}}$ value of the Fibonacci sequence. \\
\\
Then, the closed form for $T(n)$ is as follows:
\Large
\[T(n) = \frac{(\frac{1 + \sqrt{5}}{2})^{n + 1} - (\frac{1 - \sqrt{5}}{2})^{n + 1}}{\sqrt{5}}\]
\normalsize
\\
\textbf{(c):} Proof of Correctness of Closed Form Expression \\
Denote the following predicate:
\[P(n): T(n) \text{ represents the number of binary strings of length } n\]
\[\text{ where every $1$ is immediately preceded by a $0$.}\]
\textbf{\underline{Claim:}} $\forall n \in \mathbb{N}, T(n)$
\begin{proof}
\leavevmode\\
    \underline{Base Cases:} \\
    Let $n = 0$. \\
    \\
    Then,
    \large
    \[
        T(0) = \frac{(\frac{1 + \sqrt{5}}{2})^{\cancelto{1}{0 + 1}} - (\frac{1 - \sqrt{5}}{2})^{\cancelto{1}{0 + 1}}}{\sqrt{5}}
        = \frac{\frac{1 + \sqrt{5}}{2} - \frac{1 - \sqrt{5}}{2}}{\sqrt{5}}
        = \frac{\frac{\cancel{2} \sqrt{5}}{\cancel{2}}}{\sqrt{5}}
        = \frac{\cancel{\sqrt{5}}}{\cancel{\sqrt{5}}}
        = 1 \text{.}
    \]
    \normalsize
    \\
    Indeed, there is only one binary string (the empty string) with length $0$, there are simply no $1$'s. \\
    \\
    Thus, ``$0$ immediately precedes every $1$'' is vacuously true; $T(0)$. \\
    \\
    Let $n = 1$. \\
    \\
    Then,
    \large
    \[
        T(1) = \frac{(\frac{1 + \sqrt{5}}{2})^{\cancelto{2}{1 + 1}} - (\frac{1 - \sqrt{5}}{2})^{\cancelto{2}{1 + 1}}}{\sqrt{5}}
        = \frac{\frac{1 + 2 \sqrt{5} + 5}{4} - \frac{1 - 2 \sqrt{5} + 5}{4}}{\sqrt{5}}
        = \frac{\frac{\cancel{4} \sqrt{5}}{\cancel{4}}}{\sqrt{5}}
        = \frac{\cancel{\sqrt{5}}}{\cancel{\sqrt{5}}}
        = 1 \text{.}
    \]
    \normalsize
    If the string solely contains $0$, then there is simply no $1$ in the string; vacuously, this is a valid string. \\
    \\ 
    If the string solely contains $1$, then it is clearly not preceded by a $0$ which does not fit (string has length $1$).
    \\
    Therefore, there is only $1$ valid string of length $1$; $P(1)$ holds. \\
    \\
    \underline{Induction Hypothesis:} \\
    Assume for some $k \in \mathbb{N}$, for all $m \in [0, k], P(m)$. \\
    \\
    This means for some natural $k$, for all strings of length $m \in [0, k]$, there are $T(m)$ binary strings where every $1$ is immediately preceded by a $0$. \\
    \\
    \underline{Induction Step:} \\
    Evaluate $T(m + 1)$ as follows:
    \large
    \begin{equation*}
        \begin{aligned}
            T(m + 1) &= T((m + 1) - 1) + T((m + 1) - 2) \\
            &= T(m) + T(m - 1) \\
            &= \frac{(\frac{1 + \sqrt{5}}{2})^{m + 1} - (\frac{1 - \sqrt{5}}{2})^{m + 1}}{\sqrt{5}} + \frac{(\frac{1 + \sqrt{5}}{2})^{\cancelto{m}{(m - 1) + 1}} - (\frac{1 - \sqrt{5}}{2})^{\cancelto{m}{(m - 1) + 1}}}{\sqrt{5}} \\
            &= \frac{(\frac{1 + \sqrt{5}}{2})^{m + 1} - (\frac{1 - \sqrt{5}}{2})^{m + 1} + (\frac{1 + \sqrt{5}}{2})^m - (\frac{1 - \sqrt{5}}{2})^m}{\sqrt{5}} \\
            &= \frac{(\frac{1 + \sqrt{5}}{2})^{m + 1} [1 + \frac{2}{1 + \sqrt{5}}] - (\frac{1 - \sqrt{5}}{2})^{m + 1} [1 + \frac{2}{1 - \sqrt{5}}]}{\sqrt{5}} \\
            &= \frac{(\frac{1 + \sqrt{5}}{2})^{m + 1} (\frac{1 + \sqrt{5}}{2}) - (\frac{1 - \sqrt{5}}{2})^{m + 1} (\frac{1 - \sqrt{5}}{2})}{\sqrt{5}} \\
            &= \frac{(\frac{1 + \sqrt{5}}{2})^{(m + 1) + 1} - (\frac{1 - \sqrt{5}}{2})^{(m + 1) + 1}}{\sqrt{5}} \\
        \end{aligned}
    \end{equation*}
    \normalsize
    \\
    Note that $1 + \frac{2}{1 + \sqrt{5}} = \frac{1 + \sqrt{5}}{2}$ and $1 + \frac{2}{1 - \sqrt{5}} = \frac{1 - \sqrt{5}}{2}$. \\
    \\
    Therefore, $T(m + 1)$ holds for the recurrence. \\
    \\
    \underline{Conclusion:} \\
    By the Principle of Complete Induction, the $T(n)$ holds for all $n \in \mathbb{N}$. \\
\end{proof}
\leavevmode\\
\textbf{VII} \\
Let $T(n)$ denote the number of distinct full binary trees with $n$ nodes. For example, $T(1) = 1$, $T(3) = 1$, and $T(7) = 5$. Note that every full binary tree has an odd number of nodes. \\
\\
\textbf{\underline{Recurrence for $T(n)$:}} \\
The recursive part of the recurrence of $T(n)$ connects the number of nodes to the unique number of full binary trees. \\
\\
As well, the left and right subtrees can at most have $\frac{n - 3}{2}$ nodes. \\
\\
Finally, when the left subtree has $2k + 1$ nodes and the right subtree has $n - 1 - (2k + 1)$ nodes, there are $T(2k + 1)T(n - 1 - (2k + 1))$ full binary trees. \\
\\
Altogether, for particular numbers of nodes for the left and right subtree, the sum of all of these combinations is obtained. \\
\\
Therefore, denote the recurrence as follows:
\Large
\[
    T(n) =
    \begin{cases}
        1 & \text{if } n = 1 \\
        \sum_{k = 0}^{\frac{n - 3}{2}} T(2k + 1)T(n - 1 - (2k + 1)) & \text{if } n > 1 \\
        0 & \text{if } n \text{ is even}
    \end{cases}
\]
\normalsize
\large \textbf{\underline {Claim:}} \(T(n) \geq (\frac{1}{n})(2)^{(n - 1) / 2}\)
\normalsize
\begin{proof}
\leavevmode\\
    \underline{Base Case:} \\
    Let $n = 1$. \\
    \\
    Then, $T(1) = 1$ by the recurrence. \\
    \\
    Notice that $(\frac{1}{1})(2)^{(1 - 1) / 2} = 2^0 = 1$. \\
    \\
    Indeed, $T(1) = 1 \leq 1$; $T(1)$. \\
    \\
    \underline{Induction Hypothesis:} \\
    Assume for some odd $k \in \mathbb{N}$, for all odd $m \in [1, k] \cap \mathbb{N}, T(m)$. \\
    \\
    This means, for some odd natural number $k$, the number of distinct full binary trees with $m$ nodes is less than or equal to $(\frac{1}{n})(2)^{(n - 1) / 2}$, for all smaller natural numbers $m \in [1, k] \cap \mathbb{N}$ \\
    \\
    \underline{Induction Step:} \\
    Consider $T(m + 2)$. \\
    \\
    By the recurrence definition,
    \large
    \begin{equation*}
        \begin{aligned}
            T(m + 2) &= \sum_{k = 0}^{\frac{(m + 2) - 3}{2}} T(2k + 1)T(n - 1 - (2k + 1)) \\
            &= \sum_{k = 0}^{\frac{m - 1}{2}} T(2k + 1)T(n - 1 - (2k + 1)) \text{.}
        \end{aligned}
    \end{equation*}
    \normalsize
    By the Induction Hypothesis,
    \large
    \begin{equation*}
        \begin{aligned}
            &\;\;\;\; \sum_{k = 0}^{\frac{m - 1}{2}} T(2k + 1)T(n - 1 - (2k + 1)) \\
            &\geq \sum_{k = 0}^{\frac{m - 1}{2}} ((\frac{1}{2k + 1})(2)^{((2k + 1) - 1) / 2})((\frac{1}{n - 1 - (2k + 1)})(2)^{((n - 1 - (2k + 1)) - 1) / 2}) \\
            %&\geq \\
        \end{aligned}
    \end{equation*}
    \normalsize
    Therefore, by the Principle of Complete Induction, the claim holds. \\
\end{proof}
\leavevmode\\
\textbf{XII} \\
Consider the following function:
\begin{lstlisting}
def fast_rec_mult(x, y):
    n = length of x  # Assume x and y have the same length
    if n == 1:
        return x * y
    else:
        a = x // 10^(n // 2)
        b = x % 10^(n // 2)
        c = y // 10^(n // 2)
        d = y % 10^(n // 2)
        p = fast_rec_mult(a + b, c + d)
        r = fast_rec_mult(a, c)
        u = fast_rec_mult(b, d)

        return r * 10^n + (p - r + u) * 10^(n // 2) + u
\end{lstlisting}
\textbf{\underline{Worst-Case Runtime Analysis:}} \\
To find the worst-case runtime of the program, consider the program's behaviour for its base and recursive cases. \\
\\
\underline{Base Case of Program:} \\
Let $n = 1$. \\
\\
Then, by \textit{Lines 3-4}, the program returns shortly, so it runs in constant time. \\
\\
\underline{Recursive Case of Program:} \\
Let $n > 1$. \\
\\
Then, \textit{Lines 6-9} run in constant time, preparing $\frac{n}{2}$ for the recursive calls in the subsequent lines. \\
\\
To follow, \textit{Lines 10-12} has runtime $3T(\frac{n}{2})$. \\
\\
What remains is the function's return statement on \textit{Line 14}, which runs in constant time. \\
\\
This means, the recursive case has runtime $3T(\frac{n}{2}) + c$, for some constant $c$. \\
\\
Define the recurrence:
\[
    T(n) =
    \begin{cases}
        c & \text{if } n = 1 \\
        3T(\frac{n}{2}) + c & \text{if } n > 1
    \end{cases}
\]
By the Master Theorem, $a = 3, b = 2, k = 0$; $c$ is some constant. \\
\\
Notice that $a > b^k \implies 3 > 2^0 \implies 3 > 1$ (which is true). \\
\\
Therefore, $T(n) \in \Theta (n^{log_ba})$. \\
\\
By definition, $T(n) \in \Theta (n^{log_ba}) \implies T(n) \in \mathcal{O} (n^{log_ba})$. \\
\\
Because $log_ba = log_23$, the worst-case runtime of the program is $\mathcal{O} (n^{log_23})$. \\
\\
\underline{Final Answer:} \\
The worst-case runtime of the program is $\mathcal{O} (n^{log_23})$. \\
\\
\textbf{XIV} \\
Recall the recurrence for the worst-case runtime of quicksort:
\[ T(n) =
\begin{cases}
    c &\text{ if } n \leq 1 \\
    T(|L|) + T(|G|) + dn &\text{ if } n > 1 \text{,}
\end{cases}
\] where $L$ and $G$ are the partitions of the list to sort. \\
\\
For simplicity, ignore that each list has size \(\frac{n-1}{2}\). \\
\\
\textbf{(a):} Assume the lists are always evenly split; that is, \(|L| = |G| = \frac{n}{2}\) at each recursive call. \\
\textbf{\underline{Tight Asymptotic Bound on the Runtime of Quicksort:}} \\
If $n \leq 1$, then $T(n) = c$, for some constant $c$, and the program runs in constant time with the tight bound $\Theta (1)$. \\
\\
Otherwise, when $n > 1$, $T(n) = T(|L|) + T(|G|) + dn$. \\
\\
With $|L| = |G| = \frac{n}{2}$, it follows that $T(n) = T(\frac{n}{2}) + T(\frac{n}{2}) + dn = 2T(\frac{n}{2}) + dn$. \\
\\
By the Master Theorem, $a = 2, b = 2, k = 1$; $c$ is some constant $d$. \\
\\
Since $a = b^k \implies 2 = 2^1$ (which is true), $T(n) \in \Theta (n^k logn)$. \\
\\
With $k = 1$, the tight asymptotic bound on the program's runtime is $\Theta (n logn)$. \\
\\
\underline{Final Answer:} \\
The tight asymptotic bound on the program's runtime is $\Theta (n logn)$. \\
\\
\textbf{(b):} Assume the lists are always very unevenly split; that is, \(|L| = n - 2\) and \(|G| = 1\) at each recursive call. \\
\textbf{\underline{Tight Asymptotic Bound on the Runtime of Quicksort:}} \\
If $n - 2 \leq 1$, then $n \leq 3$. \\
\\
So, for $n \leq 3$, $T(n) = c$, for some constant $c$, and the program runs in constant time with the tight bound $\Theta (1)$. \\
\\
Otherwise, for $n > 3$, evaluate the closed-form for $T(n)$ as follows:
\begin{equation*}
    \begin{aligned}
        T(n) &= T(n - 2) + [\cancelto{c}{T(1)} + dn] \\
        &= T(\cancelto{(n - 4)}{(n - 2) - 2}) + [\cancelto{c}{T(1)} + d(n - 2) + [c + dn]] \\
        &= T((n - 4) - 2) + \cancelto{c}{T(1)} + d(n - 4) + [c + d(n - 2) + [c + dn]] \\
        &. \; \dots \\
        &. \; \dots \\
        &. \; \dots \\
        &= c + d(kn - \sum_{i = 0}^{k} 2i) + kc \\
        &= d[kn - (2)(\frac{(k + 1)(k)}{2})] + (k + 1)c
    \end{aligned}
\end{equation*}
Through repeated substitution, $T(0)$ is eventually reached. \\
\\
Notice that every unique call of $T(n)$ has the form $T(n - 2k)$, for some natural $k$. \\
\\
Therefore, $T(0) = T(n - 2k) \implies 0 = n - 2k \implies k = \frac{n}{2}$; the call of $T(0)$ occurs when $k = \frac{n}{2}$. \\
\\
Continue evaluating $T(n)$ with $k = \frac{n}{2}$:
\begin{equation*}
    \begin{aligned}
        T(n) &= d[kn - (\cancel{2})(\frac{(\frac{n}{2} + 1)(\frac{n}{2})}{\cancel{2}})] + (k + 1)c \\
        &= d[(\frac{n}{2})n - (\frac{n}{2} + 1)(\frac{n}{2})] + (\frac{n}{2} + 1)c \\
        &= d[\frac{n^2}{2} - \frac{n^2}{4} - \frac{n}{2}] + (\frac{n}{2} + 1)c \\
        &= d[\frac{2n^2 - n^2 - 2n}{4}] + \frac{2cn + 2c}{4} \\
        &= \frac{dn^2 - 2dn + 2cn + 2c}{4}
    \end{aligned}
\end{equation*}
Thus, $T(n) = \frac{dn^2 - 2dn + 2cn + 2c}{4}$ for $n > 3$. \\
\\
Notice that in this closed-form, $n^2$ is the term with the highest degree, so it takes precedence. \\
\\
Therefore, the tight asymptotic bound on the runtime of the program is $\Theta (n^2)$. \\
\\
\underline{Final Answer:} \\
The tight asymptotic bound on the runtime of the program is $\Theta (n^2)$. \\
\end{document}
